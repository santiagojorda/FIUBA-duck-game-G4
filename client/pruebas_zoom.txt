     // ---------------------------- Calcular Zoom ----------------------------
            // Calculamos la caja envolvente mínima que contiene a todos los patos vivos
            /*int min_x = INT_MAX, max_x = INT_MIN, min_y = INT_MAX, max_y = INT_MIN;
            for (const auto& pos: position) {
                min_x = std::min(min_x, pos.coordinate.get_x());
                max_x = std::max(max_x, pos.coordinate.get_x());
                min_y = std::min(min_y, pos.coordinate.get_y());
                max_y = std::max(max_y, pos.coordinate.get_y());
            }

            // Calcula el factor de escala (zoom) usando los límites de la caja envolvente y el tamaño de la ventana.
            float zoom_x = static_cast<float>(WINDOW_WIDTH) / (max_x - min_x + TILE_SIZE);
            float zoom_y = static_cast<float>(WINDOW_HEIGHT) / (max_y - min_y + TILE_SIZE);
            float zoom = std::min(
                    zoom_x,
                    zoom_y);  // usa el factor menor para mantener a todos los patos en pantalla

            // calcular la posición de destino para centrar la vista
            int dest_x = (WINDOW_WIDTH - static_cast<int>((max_x - min_x) * zoom)) / 2;
            int dest_y = (WINDOW_HEIGHT - static_cast<int>((max_y - min_y) * zoom)) / 2;*/

            // ---------------- Dibujar main_texture escalado ----------------

            // main_texture se renderiza en la ventana principal, aplicando el escalado calculado en zoom para simular el zoom automático.
            /*renderer.Copy(main_texture, SDL2pp::NullOpt,
                          Rect(dest_x, dest_y, static_cast<int>(WINDOW_WIDTH * zoom),
                               static_cast<int>(WINDOW_HEIGHT * zoom)));*/
